// Code generated by "gonum -types=TingShuTypeEnum"; DO NOT EDIT.
// See https://github.com/steinfletcher/gonum
package consts

import "encoding/json"
import "errors"
import "fmt"

type tingShuTypeInstanceJsonDescriptionModel struct {
	Name        string `json:"name"`
	Description string `json:"description"`
}

var tingShuTypeInstance = TingShuTypeEnum{
	NianYin: "nianYin",
	ShuYin:  "shuYin",
	Ting:    "ting",
}

// TingShuType is the enum that instances should be created from
type TingShuType struct {
	name        string
	value       string
	description string
}

// Enum instances
var NianYin = TingShuType{name: "nianYin", value: "NianYin", description: "念音网"}
var ShuYin = TingShuType{name: "shuYin", value: "ShuYin", description: "书音网"}
var Ting = TingShuType{name: "ting", value: "Ting", description: "听书网"}

// NewTingShuType generates a new TingShuType from the given display value (name)
func NewTingShuType(value string) (TingShuType, error) {
	switch value {
	case "nianYin":
		return NianYin, nil
	case "shuYin":
		return ShuYin, nil
	case "ting":
		return Ting, nil
	default:
		return TingShuType{}, errors.New(
			fmt.Sprintf("'%s' is not a valid value for type", value))
	}
}

// Name returns the enum display value
func (g TingShuType) Name() string {
	switch g {
	case NianYin:
		return NianYin.name
	case ShuYin:
		return ShuYin.name
	case Ting:
		return Ting.name
	default:
		return ""
	}
}

// String returns the enum display value and is an alias of Name to implement the Stringer interface
func (g TingShuType) String() string {
	return g.Name()
}

// Error returns the enum name and implements the Error interface
func (g TingShuType) Error() string {
	return g.Name()
}

// Description returns the enum description if present. If no description is defined an empty string is returned
func (g TingShuType) Description() string {
	switch g {
	case NianYin:
		return "念音网"
	case ShuYin:
		return "书音网"
	case Ting:
		return "听书网"
	default:
		return ""
	}
}

// TingShuTypeNames returns the displays values of all enum instances as a slice
func TingShuTypeNames() []string {
	return []string{
		"nianYin",
		"shuYin",
		"ting",
	}
}

// TingShuTypeValues returns all enum instances as a slice
func TingShuTypeValues() []TingShuType {
	return []TingShuType{
		NianYin,
		ShuYin,
		Ting,
	}
}

// MarshalJSON provides json serialization support by implementing the Marshaler interface
func (g TingShuType) MarshalJSON() ([]byte, error) {
	if g.Description() != "" {
		m := tingShuTypeInstanceJsonDescriptionModel{
			Name:        g.Name(),
			Description: g.Description(),
		}
		return json.Marshal(m)
	}
	return json.Marshal(g.Name())
}

// UnmarshalJSON provides json deserialization support by implementing the Unmarshaler interface
func (g *TingShuType) UnmarshalJSON(b []byte) error {
	var v interface{}
	err := json.Unmarshal(b, &v)
	if err != nil {
		return err
	}

	var value string
	switch v.(type) {
	case map[string]interface{}:
		value = v.(map[string]interface{})["name"].(string)
	case string:
		value = v.(string)
	}

	instance, createErr := NewTingShuType(value)
	if createErr != nil {
		return createErr
	}

	g.name = instance.name
	g.value = instance.value
	g.description = instance.description

	return nil
}
